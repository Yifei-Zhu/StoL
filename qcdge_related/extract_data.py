import os

import pandas as pd
import h5py
from tqdm import tqdm

from rdkit import Chem


class extractData():
    def __init__(self, mol_list=[], order = None, prop_list=[],hdf5_file='./final_all_remove_duplicate.hdf5', csv_file='./final_all_remove_duplicate.csv', heavy_atom_threshold=None, element_input=None):

        if not order:
            order = int(input('Enter a specific number to choose a way to filter molecules \n1 - all molecules\n2 - a list of molecular index (You should provide a list using the keyword "mol_list" in code)\n3 - filter according to some criteria\n9 - HELP FOR PROPs\n'))

        self.option = order
        self.hdf5 = hdf5_file

        self.csv = csv_file

        self.prop_list = prop_list or self.collect_prop_list()
        
        if mol_list:
            assert self.option == 2, "You input a mol_list but do not use them?"
        
        if self.option == 2:
            if not mol_list:
                raise ValueError("ERROR: NO MOL_LIST INPUT!")
            self.mol_list = mol_list
        elif self.option == 3:
            self.mol_list = self.filter_molecules(heavy_atom_threshold=heavy_atom_threshold, element_input=element_input)
    
        self.data = {
            '1': {'Key': 'labels', 'Description': 'Atomic labels.'},
            '2': {'Key': 'coords', 'Description': 'Optimized Cartesian coordinates.'},
            '3': {'Key': 'Etot', 'Description': 'Total energy.'},
            '4': {'Key': 'e_homo_lumo', 'Description': 'Energy of HOMO and LUMO.'},
            '5': {'Key': 'polarizability', 'Description': 'Isotropic polarizability.'},
            '6': {'Key': 'dipole', 'Description': 'Dipole moment.'},
            '7': {'Key': 'quadrupole', 'Description': 'Quadrupole moment.'},
            '8': {'Key': 'zpve', 'Description': 'Zero point vibrational energy.'},
            '9': {'Key': 'rot_constants', 'Description': 'Rotational constant.'},
            '10': {'Key': 'elec_spatial_ext',
            'Description': 'Electronic spatial extent.'},
            '11': {'Key': 'thermal', 'Description': 'Thermal properties at 298.15 K.'},
            '12': {'Key': 'freqs', 'Description': 'Harmonic vibrational frequencies.'},
            '13': {'Key': 'mulliken', 'Description': 'Mulliken charges.'},
            '14': {'Key': 'cv', 'Description': 'Heat capacity at 298.15 K.'},
            '15': {'Key': 'Etot', 'Description': 'Total energy.'},
            '16': {'Key': 'e_homo_lumo', 'Description': 'Energy of HOMO and LUMO.'},
            '17': {'Key': 'dipole', 'Description': 'Dipole moment.'},
            '18': {'Key': 'quadrupole', 'Description': 'Quadrupole moment.'},
            '19': {'Key': 'rot_constants', 'Description': 'Rotational constant.'},
            '20': {'Key': 'elec_spatial_ext',
            'Description': 'Electronic spatial extent.'},
            '21': {'Key': 'mulliken', 'Description': 'Mulliken charges.'},
            '22': {'Key': 'transition_electric_DM',
            'Description': 'Transition electric dipole moments.'},
            '23': {'Key': 'transition_velocity_DM',
            'Description': 'Transition velocity dipole moments.'},
            '24': {'Key': 'transition_magnetic_DM',
            'Description': 'Transition magnetic dipole moments.'},
            '25': {'Key': 'transition_velocity_QM',
            'Description': 'Transition velocity quadrupole moments.'},
            '26': {'Key': 'OrbNum_HomoLumo',
            'Description': 'The orbital number of HOMO and LUMO.'},
            '27': {'Key': 'Info_of_AllExcitedStates',
            'Description': 'The transition contribution of 10 singlet and 10 triplet transition states.'},
            '101':{'Key':'SMILES_PYBEL','Description':'Smiles generated by pybel.'},
            '102':{'Key':'INCHI_PYBEL','Description':'Smiles generated by pybel.'},
            '103':{'Key':'SMILES_RDKIT','Description':'Smiles generated by pybel.'},
            '104':{'Key':'INCHI_RDKIT','Description':'Smiles generated by pybel.'},
            '105':{'Key':'SMILES_RDKIT_CAN','Description':'Smiles generated by pybel.'},
        }


    def read_from_hdf5_no_ProgressBar(self):
        data_dict = {}

        with h5py.File(self.hdf5, 'r') as f:
            for prop_ind in self.prop_list:
                keyword = 'ground_state' if prop_ind <= 14 else 'excited_state'
                prop = self.data[str(prop_ind)]['Key']
                data_dict[prop] = []

                db_names = self.mol_list if self.option != 1 else f.keys()
                data_dict['mol'] = db_names
                for db_name in db_names:
                    if str(db_name) in f:
                        group = f[str(db_name)]
                        if prop_ind > 100:
                            data_dict[prop].append(group.attrs.get(prop))
                        else:
                            data_dict[prop].append(group[keyword][prop][()].tolist())

        # print(data_dict)
        return data_dict
    
    def read_from_hdf5(self):
        data_dict = {}

        with h5py.File(self.hdf5, 'r') as f:
            for prop_ind in tqdm(self.prop_list, desc="Processing properties"):
                keyword = 'ground_state' if prop_ind <= 14 else 'excited_state'
                prop = self.data[str(prop_ind)]['Key']
                data_dict[prop] = []

                db_names = self.mol_list if self.option != 1 else [str(name) for name in f.keys()]
                data_dict['mol'] = db_names
                for db_name in tqdm(db_names, desc=f"Processing molecules for property {prop}", leave=False):
                    if str(db_name) in f:
                        group = f[str(db_name)]
                        if prop_ind > 100:
                            data_dict[prop].append(group.attrs.get(prop))
                        else:
                            data_dict[prop].append(group[keyword][prop][()].tolist())

        # print(data_dict)
        return data_dict

    @property
    def props(self):
        from rich.table import Table
        from rich.console import Console

        console = Console()
        # ground-state
        console.print('Props from ground-state calculation (b3lyp/6-31g*+BJD3):')
        gs_table = Table(show_header=True, header_style="bold green", border_style = "bold green")
        gs_table.add_column("No.", style="dim")
        gs_table.add_column("Key")
        gs_table.add_column("Description")
        for no in range(1, 15):
            no_str = str(no)
            if no_str in self.data:
                item = self.data[no_str]
                gs_table.add_row(no_str, item["Key"], item["Description"])
        console.print(gs_table)

        #excited-state
        console.print('\nProps from excited-state calculation (wb97xd/6-31g*):')
        es_table = Table(show_header=True, header_style="bold green", border_style = "bold green")
        es_table.add_column("No.", style="dim")
        es_table.add_column("Key")
        es_table.add_column("Description")
        for no in range(15, 28):
            no_str = str(no)
            if no_str in self.data:
                item = self.data[no_str]
                es_table.add_row(no_str, item["Key"], item["Description"])
        console.print(es_table)


    @staticmethod
    def collect_prop_list():
        props = []
        print("\nPlease enter the numbers, separated by the enter key, ending with '#'. If you enter '*', all props are included:\n")

        while True:
            user_input = input()
            if user_input == '*':
                props = list(range(1,28))
                props += [101, 102, 103, 104, 105]
                break
            elif user_input == '#':
                break
            try:
                prop = int(user_input)
                props.append(prop)
            except ValueError:
                print("Invalid input, please enter a number or '#' to end.\n")
        return props

    def filter_molecules(self, heavy_atom_threshold=None, element_input=None):
        heavy_atom_threshold = heavy_atom_threshold or input(
            "\nEnter the heavy atom threshold:\n"
            "e.g.,\n"
            "8 - Molecules with <=8 heavy atoms will be selected.\n"
            "2,6 - Interval [2,6] for the number of heavy atoms.\n"
        )

        element_input = element_input.split(',') or input(
            "\nEnter heavy atom types (e.g., 6,7,8 for C, N, O):\n"
            "Available options: 6 - C, 7 - N, 8 - O, 9 - F.\n"
        ).split(',')

        elements_list={
            6:'C',
            7:'N',
            8:'O',
            9:'F',
        }

        elements = [elements_list[int(e)] for e in element_input]

        df = pd.read_csv(self.csv)
        thr = heavy_atom_threshold.split(',')

        if len(thr) ==2:
            threshold1 = int(heavy_atom_threshold.split(',')[0])
            threshold2 = int(heavy_atom_threshold.split(',')[1])
            selected_df = df[(df['HeavyAtomCount'] >= threshold1) & (df['HeavyAtomCount'] <= threshold2)]
            # print(selected_df)
        else:
            selected_df = df[(df['HeavyAtomCount'] <= int(heavy_atom_threshold))]

        self.mol_list = []
        for _, row in tqdm(selected_df.iterrows(), total=len(selected_df), desc="Filtering molecules"):
            if row['Smiles_rdkit'] == '1':
                continue

            molecule = Chem.MolFromSmiles(row['Smiles_rdkit']) if Chem.MolFromSmiles(row['Smiles_rdkit']) else Chem.MolFromInchi(row['InchI_pybel'])

            if molecule is None:
                continue

            atom_elements = set(atom.GetSymbol() for atom in molecule.GetAtoms())

            if atom_elements.issubset(set(elements)):
                self.mol_list.append(row['Index'])

        print(f'Total filtered mol: {len(self.mol_list)}')
        return self.mol_list

if __name__ == '__main__':
    extractor = extractData(mol_list=['Ba000010932'],hdf5_file='/data/home/zhuyf/dataset_work/database/checkOptedGeoms/final_all.hdf5')
    data_dict = extractor.read_from_hdf5()
